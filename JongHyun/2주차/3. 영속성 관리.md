# 영속성 컨텍스트란?

* JPA를 이해하는데 가장 중요한 용어
* “엔티티를 영구 저장하는 환경”이라는 뜻
* `EntityManager.persist(entity);`

> 전 챕터에서 `EntityManager.persist(Member);` 를 통해 맴버를 저장했었는데 이는 데이터베이스에 저장한다는 의미가 아니고  
> 영속성 컨텍스트 라는 곳에 저장하겠다는 의미이다.

>엔티티 매니저의 역할은 눈에 보이지 않는 영속성 컨텍스트 라는 공간에 접근하여 여러 작업을 해주는 녀석이라고 생각하면 된다.

<img src="src/data1.png">

엔티티 매니저를 생성하면 눈에 보이지 않는 영속성 컨텍스트가 하나 생긴다.
즉, 엔티티 매니저 하나당 영속성 컨텍스트를 하나씩 가지고 있어 1:1 매칭이 된다.

# 엔티티의 생명주기

<img src="src/data2.png">

<img src="src/data3.png">

## 비영속

<img src="src/data4.png">

객체를 생성만 한 상태에는 `JPA` 와 관계없이 `영속성 컨텍스트`에서 관리해주지 않기 때문에 `비영속` 상태라고 한다.


## 영속

<img src="src/data5.png">

객체를 생성하고 `엔티티 매니저`를 통해 `persist`를 하게 되면 `영속성 컨텍스트`에 객체가 들어가면서 `영속` 상태가 된다.

```java
public class JpaMain {

  public static void main(String[] args) {
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

    EntityManager em = emf.createEntityManager();

    EntitiyTransaction tx = em.getTransaction();
    tx.begin(); // 트렌젝션 시작

    try {
        //비영속
        Member member = new Member();
        member.setId(100L);
        member.setName("HelloJPA");
  
        //영속
        em.persist(member);
  
        tx.commit(); // 트렌젝션 커밋
    } catch (Exception e) {
        tx.rollback(); //예외가 발생하면 트렌젝션 롤벡
    }finally {
        entityManager.close();
    }
    

    enf.close();
  }
}
```

> 앞에서 `em.persist(member)` 를 하면 저장된다고 했었는데 사실, 이 순간 디비에 저장되는 것이 아니고  
>이 순간에는 영속성 컨텍스트에 저장만 해놓는다.   
> 디비에 저장하는 쿼리를 보내는 순간은 바로 `tx.commit()`  하는 시점 즉, 트렌젝션이 커밋을 하는 순간에 디비에 `SQL`을 보낸다.


## 준영속

```java
em.detach(member);
```

>위 코드 처럼 작성하면 영속성 컨텍스트에서 회원 엔티티를 분리 하겠다는 의미이며 이를 `준영속` 이라고 부른다.


## 삭제

```java
em.remove(member);
```

>위 코드는 회원 엔티티를 디비에서 삭제해달라고 요청해달라는 의미이다.


# 영속성 컨텍스트의 이점

영속성 컨텍스트를 채용함으로써 얻는 이점은 다음과 같은 것들이 있다.
* 1차 캐시
* 동일성(identity) 보장
* 트랜잭션을 지원하는 쓰기 지연  (transactional write-behind)
* 변경 감지(Dirty Checking)
* 지연 로딩(Lazy Loading)



## 엔티티 조회, 1차 캐시