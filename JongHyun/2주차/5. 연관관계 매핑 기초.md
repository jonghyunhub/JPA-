# 연관관계가 필요한 이유

예제 시나리오
* 회원과 팀이 있다.
* 회원은 하나의 팀에만 소속될 수 있다.
* 회원과 팀은 다대일 관계다.


<img src="src/5.%20연관관계%20매핑%20기초/data1.png">

<img src="src/5.%20연관관계%20매핑%20기초/data2.png">

<img src="src/5.%20연관관계%20매핑%20기초/data3.png">

<img src="src/5.%20연관관계%20매핑%20기초/data4.png">

> 이런식으로 설계하면 객체 지향의 장점을 포기할수 밖에 없고 `JPA`를 사용하는 의미가 크게 없어진다.

##  객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
 
* 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
* 객체는 참조를 사용해서 연관된 객체를 찾는다.
* 테이블과 객체 사이에는 이런 큰 간격이 있다.

## 단방향 연관관계

<img src="src/5.%20연관관계%20매핑%20기초/data5.png">

기존에 `TeamID` 로 매핑하던 부분을 `Team` 객체로 변경했다.
이때 `Team`  객체와  `Member` 객체가 어떤관게인지 `JPA` 에게 알려주기 위해
`@ManyToOne` 을 붙여주고 `Team` 객체가 디비의 어떤 컬럼과 매핑되는지를 알려주기 위해
`@JoinColumn` 을 붙여준다.

<img src="src/5.%20연관관계%20매핑%20기초/data6.png">

<img src="src/5.%20연관관계%20매핑%20기초/data7.png">

<img src="src/5.%20연관관계%20매핑%20기초/data8.png">

<img src="src/5.%20연관관계%20매핑%20기초/data9.png">

> `JPA`를 사용하면 자바에서 객체를 다루는 것 처럼 디비의 데이터를 다룰 수 있게된다.

# 양방향 연관관계와 연관관계의 주인

## 양방향 매핑 

위에서 설계한 매핑은 `Member` 에서 `Team`으로는 참조가 가능했지만 반대로는 불가능 했다.  
반대방향에서도 참조가 가능하게 하기 위해 다음과 같이 매핑을 변경해보자.

<img src="src/5.%20연관관계%20매핑%20기초/data10.png">

허나 위와 같이 변경하면 객체 설계는 변하지만 테이블 구조는 그대로이다.  
테이블 구조는 `PK`, `FK`로 테이블 조인을 통해 양방향 접근이 가능하기 때문이다.

<img src="src/5.%20연관관계%20매핑%20기초/data11.png">

<img src="src/5.%20연관관계%20매핑%20기초/data12.png">

>`mappedBy`는 반대편 엔티티의 어떤 필드와 매핑되는지 알려주는 속성이다.

<img src="src/5.%20연관관계%20매핑%20기초/data13.png">

## 연관관계의 주인과 mappedBy

객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.

### 객체와 테이블이 관계를 맺는 차이

* 객체 연관관계 = 2개
  * 회원 -> 팀 연관관계 1개(단방향)
  * 팀 -> 회원 연관관계 1개(단방향)
* 테이블 연관관계 = 1개
  *  회원 <-> 팀의 연관관계 1개(양방향)

<img src="src/5.%20연관관계%20매핑%20기초/data14.png">

객체는 참조변수가 2개(`team`,`members`)가 있는 반면
테이블은 `Member`의 `TEAM_ID`(FK) 로 양쪽 다 연결이 가능하다.

* 객체 연관관계 = 2개
  * 회원 -> 팀 연관관계 1개(단방향)
  * 팀 -> 회원 연관관계 1개(단방향)
* 테이블 연관관계 = 1개
  * 회원 <-> 팀의 연관관계 1개(양방향)

### 객체의 양방향 관계

* 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단 뱡향 관계 2개다.
* 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.
* 
* A -> B (a.getB())
```java
class A{
    B b;
}
```

* B -> A (b.getA())
```java
class B{
    A a;
}
```

### 테이블의 양방향 연관관계

* 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
* MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐  (양쪽으로 조인할 수 있다.)

```sql
 SELECT *
 FROM MEMBER M
 JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

 SELECT *
 FROM TEAM T
 JOIN MEMBER M ON T.TEAM_ID  = M.TEAM_ID
```
<img src="src/5.%20연관관계%20매핑%20기초/data15.png">

외래 키(FK)를 객체의 어떤 레퍼런스로 관리해야하는지 문제가 생긴다. 
이런 문제 때문에 생긴 개념이 `연관관계인 주인(Owner)` 이다.

### 연관관계의 주인(Owner)

양방향 매핑 규칙

* 객체의 두 괸계중 하나를 연관관계의 주인으로 지정
* 연관관계의 주인만이 외래 키를 관리(등록, 수정)
* 주인이 아닌쪽은 읽기만 가능
* 주인은 mappedBy 속성 사용X 
* 주인이 아니면  mappedBy 속성으로 주인 지정

<img src="src/5.%20연관관계%20매핑%20기초/data16.png">

> `FK` 가 있는 테이블의 객체를 주인으로 정하면 된다.
> 만약, `Team`을 주인으로 정했을때 값을 변경하면 다른 테이블에 `update` 쿼리가 나가기 때문에
> 혼란이 생길수 있다. 따라서, 이 경우 `Member`를 연관관계의 주인으로 하면 된다.
