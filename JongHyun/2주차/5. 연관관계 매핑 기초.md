# 연관관계가 필요한 이유

예제 시나리오
* 회원과 팀이 있다.
* 회원은 하나의 팀에만 소속될 수 있다.
* 회원과 팀은 다대일 관계다.


<img src="src/5.%20연관관계%20매핑%20기초/data1.png">

<img src="src/5.%20연관관계%20매핑%20기초/data2.png">

<img src="src/5.%20연관관계%20매핑%20기초/data3.png">

<img src="src/5.%20연관관계%20매핑%20기초/data4.png">

> 이런식으로 설계하면 객체 지향의 장점을 포기할수 밖에 없고 `JPA`를 사용하는 의미가 크게 없어진다.

##  객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
 
* 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
* 객체는 참조를 사용해서 연관된 객체를 찾는다.
* 테이블과 객체 사이에는 이런 큰 간격이 있다.

## 단방향 연관관계

<img src="src/5.%20연관관계%20매핑%20기초/data5.png">

기존에 `TeamID` 로 매핑하던 부분을 `Team` 객체로 변경했다.
이때 `Team`  객체와  `Member` 객체가 어떤관게인지 `JPA` 에게 알려주기 위해
`@ManyToOne` 을 붙여주고 `Team` 객체가 디비의 어떤 컬럼과 매핑되는지를 알려주기 위해
`@JoinColumn` 을 붙여준다.

<img src="src/5.%20연관관계%20매핑%20기초/data6.png">

<img src="src/5.%20연관관계%20매핑%20기초/data7.png">

<img src="src/5.%20연관관계%20매핑%20기초/data8.png">

<img src="src/5.%20연관관계%20매핑%20기초/data9.png">

> `JPA`를 사용하면 자바에서 객체를 다루는 것 처럼 디비의 데이터를 다룰 수 있게된다.

# 양방향 연관관계와 연관관계의 주인

## 양방향 매핑 

위에서 설계한 매핑은 `Member` 에서 `Team`으로는 참조가 가능했지만 반대로는 불가능 했다.  
반대방향에서도 참조가 가능하게 하기 위해 다음과 같이 매핑을 변경해보자.

<img src="src/5.%20연관관계%20매핑%20기초/data10.png">

허나 위와 같이 변경하면 객체 설계는 변하지만 테이블 구조는 그대로이다.  
테이블 구조는 `PK`, `FK`로 테이블 조인을 통해 양방향 접근이 가능하기 때문이다.

<img src="src/5.%20연관관계%20매핑%20기초/data11.png">

<img src="src/5.%20연관관계%20매핑%20기초/data12.png">

>`mappedBy`는 반대편 엔티티의 어떤 필드와 매핑되는지 알려주는 속성이다.

<img src="src/5.%20연관관계%20매핑%20기초/data13.png">

## 연관관계의 주인과 mappedBy

객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.

### 객체와 테이블이 관계를 맺는 차이

* 객체 연관관계 = 2개
  * 회원 -> 팀 연관관계 1개(단방향)
  * 팀 -> 회원 연관관계 1개(단방향)
* 테이블 연관관계 = 1개
  *  회원 <-> 팀의 연관관계 1개(양방향)

<img src="src/5.%20연관관계%20매핑%20기초/data14.png">

객체는 참조변수가 2개(`team`,`members`)가 있는 반면
테이블은 `Member`의 `TEAM_ID`(FK) 로 양쪽 다 연결이 가능하다.

* 객체 연관관계 = 2개
  * 회원 -> 팀 연관관계 1개(단방향)
  * 팀 -> 회원 연관관계 1개(단방향)
* 테이블 연관관계 = 1개
  * 회원 <-> 팀의 연관관계 1개(양방향)

