# 상속관계 매핑

<img src="src/7.%20고급%20매핑/data1.png">

* 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
  * 각각 테이블로 변환-> 조인 전략
  * 통합 테이블로 변환 -> 단일 테이블 전략
  * 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략
  

## 주요 어노테이션

* `@Inheritance(strategy=InheritanceType.XXX)` 
  * `JOINED`: 조인 전략
* `SINGLE_TABLE`: 단일 테이블 전략
  * `TABLE_PER_CLASS`: 구현 클래스마다 테이블 전략 `@DiscriminatorColumn(name=“DTYPE”)`
* `@DiscriminatorValue(“XXX”)`

>`JPA`를 사용하면 전략이 바뀌어도 `@Inheritance(strategy=InheritanceType.XXX)` 의 설정만 바꿔주고 다른 코드의 수정이 필요없다!

<img src="src/7.%20고급%20매핑/data2.png">

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```

```java
@Entity
public class Album extends Item {
    private String artist;
}
```

```java
@Entity
public class Book extends Item {
    private String author;
    private String isbn;
}
```

```java
@Entity
public class Movie extends Item {
    private String director;
    private String actor;
}
```

> 위와 같이 코드를 작성하면 위 그림처럼 테이블이 생성된다.
> 특히, `Item` 테이블의 `@Inheritance(strategy = InheritanceType.JOINED)`은 전략을 설정해주는 에너테이션이고
> `@DiscriminatorColumn` 은 인서트 할때 어떤 항목인지 알려주는 컬럼을 추가하는 에너테이션이다.
> 기본값으로는 `DTYPE` 컬럼을 추가해준다.
> 또한, 자식 엔티티(여기서는 Album, Book ,Movie) 에서 `@DiscriminatorValue(“XXX”)`를 추가해서 값을 넣었을때 `DTYPE` 컬럼에 어떤값이 들어갈지 세팅해줄수도 있다.(기본값으로는 엔티티 이름)

* 장점
  * 테이블 정규화
  * 외래 키 참조 무결성 제약조건 활용가능 
  * 저장공간 효율화
* 단점
  * 조회시조인을많이사용, 성능저하
  * 조회 쿼리가 복잡함
  * 데이터 저장시 INSERT SQL 2번 호출



<img src="src/7.%20고급%20매핑/data3.png">

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn
public class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```

```java
@Entity
public class Album extends Item {
    private String artist;
}
```

```java
@Entity
public class Book extends Item {
    private String author;
    private String isbn;
}
```

```java
@Entity
public class Movie extends Item {
    private String director;
    private String actor;
}
```

> 이 전략에서는 기존에 객체는 그대로 두되,   
> `ITEM` 엔티티의 `@Inheritance` 에너테이션에서 옵션만 `SINGLE_TABLE` 으로 두면 된다.
> 단일 테이블 전략에서는 `@DiscriminatorColumn`가 필수이다. (이게 없으면 어떤 엔티티인지 구분이 안됨)

* 장점
  * 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
  * 조회 쿼리가 단순함 
* 단점
  * 자식 엔티티가 매핑한 컬럼은 모두 null 허용
  * 단일 테이블에 모든 것을 저장하므로 테이블이 커질수있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.


<img src="src/7.%20고급%20매핑/data4.png">

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Item {

    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```

```java
@Entity
public abstract class Album extends Item {
    private String artist;
}
```

```java
@Entity
public class Book extends Item {
    private String author;
    private String isbn;
}
```

```java
@Entity
public class Movie extends Item {
    private String director;
    private String actor;
}
```

> 이 전략에서는 `@DiscriminatorColumn` 가 의미가 없으므로 사용하지 않았다.
> 왜냐하면 `ITEM` 테이블 자체가 생성되지 않으므로 구분할 필요가 없기 때문

> 구현 클래스마다 테이블 전략에는 치명적인 단점이 있는데 바로
> 조회할때 클래스 타입으로 조회한다고 했을때 `Item` 타입으로 조회하면 
> 쿼리를 `ALBUM`, `BOOK`, `MOVIE` 테이블을 전부  `UNION` 해서 가져오기 때문에 성능상 불리하다.

* 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X 
* 장점
  * 서브 타입을 명확하게 구분해서 처리할 때 효과적
  * not null 제약조건 사용 가능
* 단점
  * 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
  * 자식 테이블을 통합해서 쿼리하기 어려움


### 결론 : `JOIN 전략`이 정석이라고 생각하면 된다. 그리고 `구현 클래스마다 테이블 전략` 은 사용하면 안되는 전략이